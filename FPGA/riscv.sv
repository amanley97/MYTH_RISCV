`line 2 "core.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   // Included URL: "https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/2d6d36baa4d2bc62321f982f78c8fe1456641a43/risc-v_defs.tlv"

//_\SV
   module riscv(input clk, input reset, input [31:0] idata0, idata1, idata2, idata3, idata4, idata5, idata6, idata7, idata8, idata9, idata10, idata11, idata12, idata13, idata14, idata15, idata16, idata17, idata18, idata19, idata20, idata21, idata22, idata23, idata24, idata25, idata26, idata27, idata28, idata29, idata30, idata31, output reg [31:0] reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7, reg8, reg9, reg10, reg11, reg12, reg13, reg14, reg15, reg16, reg17, reg18, reg19, reg20, reg21, reg22, reg23, reg24, reg25, reg26, reg27, reg28, reg29, reg30, reg31); wire cyc_cnt; wire passed; wire failed; assign cyc_cnt = 100; // cyc_cnt, passed and failed signals are valid only when running on makerchip, not valid here!   // (Expanded in Nav-TLV pane.)
`include "riscv_gen.sv" //_\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
                // Initialize r10 (a0) to 0.
   // Function:
               // Initialize sum register a4 with 0x0
            // Store count of 10 in register a2.
               // Initialize intermediate sum register a3 with 0
   // Loop:
              // Incremental addition
               // Increment intermediate register by 1
    // If a3 is less than a2, branch to label named <loop>
               // Store final result to register a0 so that it can be read by main program
   
   //Data memory test
    //stores the result in memory
    //loads the final result to r15
   
   // Optional:
   //m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   
   

   //_|cpu
      //_@0
         assign CPU_reset_a0 = reset;
         
         // PROGRAM COUNTER
         assign CPU_pc_a0[31:0] = CPU_reset_a1                     ? 32'd0 :
                     CPU_valid_taken_br_a3            ? CPU_br_tgt_pc_a3 :
                     CPU_valid_load_a3                ? CPU_inc_pc_a1 :
                     (CPU_valid_jump_a3 && CPU_is_jal_a3)  ? CPU_br_tgt_pc_a3 :
                     (CPU_valid_jump_a3 && CPU_is_jalr_a3) ? CPU_jalr_tgt_pc_a3 :
                     CPU_inc_pc_a1;
         
         // INSTRUCTION MEMORY
         assign CPU_imem_rd_en_a0 = !CPU_reset_a0; //enable reads when not reset.
         assign CPU_imem_rd_addr_a0[30-1:0] = CPU_pc_a0[30+1:2]; //data out is PC+4. 
      
      //_@1
         assign CPU_inc_pc_a1[31:0] = CPU_pc_a1 + 32'd4;
         assign CPU_instr_a1[31:0]  = CPU_imem_rd_data_a1;
         
         // DECODER         
         assign CPU_is_i_instr_a1 = CPU_instr_a1[6:2] ==? 5'b0000x || //00000 and 00001 are i-type.
                       CPU_instr_a1[6:2] ==? 5'b001x0 || //00100 and 00110 are i-type.
                       CPU_instr_a1[6:2] ==? 5'b11001 || 
                       CPU_instr_a1[6:2] ==? 5'b11100;
         assign CPU_is_r_instr_a1 = CPU_instr_a1[6:2] ==? 5'b011x0 || //01100 and 01110 are r-type.
                       CPU_instr_a1[6:2] ==? 5'b01011 || 
                       CPU_instr_a1[6:2] ==? 5'b10100;
         assign CPU_is_s_instr_a1 = CPU_instr_a1[6:2] ==? 5'b0100x;   //01000 and 01001 are s-type.
         assign CPU_is_b_instr_a1 = CPU_instr_a1[6:2] ==  5'b11000;
         assign CPU_is_j_instr_a1 = CPU_instr_a1[6:2] ==  5'b11011;
         assign CPU_is_u_instr_a1 = CPU_instr_a1[6:2] ==? 5'b0x101;   //00101 and 01101 are u-type.
         
         // OPCODE FIELD
         assign CPU_opcode_a1[6:0] = CPU_instr_a1[6:0];
         
         // IMMEDIATE FIELD
         assign CPU_imm_a1[31:0] = CPU_is_i_instr_a1 ? { {21{CPU_instr_a1[31]}}, CPU_instr_a1[30:20] } : //21{$instr[31]} is basically a s-ext of bit 31.
                      CPU_is_s_instr_a1 ? { {21{CPU_instr_a1[31]}}, CPU_instr_a1[30:25], CPU_instr_a1[11:7] } :
                      CPU_is_b_instr_a1 ? { {20{CPU_instr_a1[31]}}, CPU_instr_a1[7], CPU_instr_a1[30:25], CPU_instr_a1[11:8], 1'b0 } :
                      CPU_is_u_instr_a1 ? { CPU_instr_a1[31:12], 12'd0 } :
                      CPU_is_j_instr_a1 ? { CPU_instr_a1[31:12], CPU_instr_a1[20], CPU_instr_a1[30:21], 1'b0 } :
                                    32'd0;
         
         // FUNCTION FIELDS
         assign CPU_funct7_valid_a1 = CPU_is_r_instr_a1;
         assign CPU_funct3_valid_a1 = CPU_is_r_instr_a1 || CPU_is_i_instr_a1 || CPU_is_s_instr_a1 || CPU_is_b_instr_a1;
         
         //_?$funct7_valid
            assign CPU_funct7_a1[6:0] = CPU_instr_a1[31:25]; //funct7 field.
         //_?$funct3_valid
            assign CPU_funct3_a1[2:0] = CPU_instr_a1[14:12]; //funct3 field.
         
         // REGISTER FIELDS
         assign CPU_rs1_valid_a1 = CPU_is_r_instr_a1 || CPU_is_i_instr_a1 || CPU_is_s_instr_a1 || CPU_is_b_instr_a1;
         assign CPU_rs2_valid_a1 = CPU_is_r_instr_a1 || CPU_is_s_instr_a1 || CPU_is_b_instr_a1;
         assign CPU_rd_valid_a1  = CPU_is_r_instr_a1 || CPU_is_i_instr_a1 || CPU_is_u_instr_a1 || CPU_is_j_instr_a1;
         
         //_?$rs1_valid
            assign w_CPU_rs1_a1[4:0]    = CPU_instr_a1[19:15]; //source register 1.
         //_?$rs2_valid
            assign w_CPU_rs2_a1[4:0]    = CPU_instr_a1[24:20]; //source register 2.
         //_?$rd_valid
            assign w_CPU_rd_a1[4:0]     = CPU_instr_a1[11:7];  //destination register.
         
         assign CPU_dec_bits_a1[10:0] = {CPU_funct7_a1[5], CPU_funct3_a1, CPU_opcode_a1};
         
         // INSTRUCTION SET (RV32I)      
         assign CPU_is_lui_a1    = CPU_dec_bits_a1 ==? 11'bx_xxx_0110111; //load upper immediate
         assign CPU_is_auipc_a1  = CPU_dec_bits_a1 ==? 11'bx_xxx_0010111; //add upper immediate to PC
         assign CPU_is_jal_a1    = CPU_dec_bits_a1 ==? 11'bx_xxx_1101111; //jump and link
         assign CPU_is_jalr_a1   = CPU_dec_bits_a1 ==? 11'bx_000_1100111; //jump and link register
         assign CPU_is_jump_a1   = CPU_is_jal_a1 || CPU_is_jalr_a1;
         
         assign CPU_is_beq_a1    = CPU_dec_bits_a1 ==? 11'bx_000_1100011; //branch equal 
         assign CPU_is_bne_a1    = CPU_dec_bits_a1 ==? 11'bx_001_1100011; //branch not equal 
         assign CPU_is_blt_a1    = CPU_dec_bits_a1 ==? 11'bx_100_1100011; //branch less than
         assign CPU_is_bge_a1    = CPU_dec_bits_a1 ==? 11'bx_101_1100011; //branch greater than or equal to 
         assign CPU_is_bltu_a1   = CPU_dec_bits_a1 ==? 11'bx_110_1100011; //branch less than (unsigned)
         assign CPU_is_bgeu_a1   = CPU_dec_bits_a1 ==? 11'bx_111_1100011; //branch greater or equal (unsigned)
         
         assign CPU_is_lb_a1     = CPU_dec_bits_a1 ==? 11'bx_000_0000011; //load byte
         assign CPU_is_lh_a1     = CPU_dec_bits_a1 ==? 11'bx_001_0000011; //load half-word
         assign CPU_is_lw_a1     = CPU_dec_bits_a1 ==? 11'bx_010_0000011; //load word
         assign CPU_is_lbu_a1    = CPU_dec_bits_a1 ==? 11'bx_100_0000011; //load byte (unsigned)
         assign CPU_is_lhu_a1    = CPU_dec_bits_a1 ==? 11'bx_101_0000011; //load half-word (unsigned)
         assign CPU_is_load_a1   = (CPU_is_lb_a1 || CPU_is_lh_a1 || CPU_is_lw_a1 || CPU_is_lbu_a1 || CPU_is_lhu_a1); //handle all loads indiscriminantly
         
         assign CPU_is_sb_a1     = CPU_dec_bits_a1 ==? 11'bx_000_0100011; //store byte
         assign CPU_is_sh_a1     = CPU_dec_bits_a1 ==? 11'bx_001_0100011; //store half-word
         assign CPU_is_sw_a1     = CPU_dec_bits_a1 ==? 11'bx_010_0100011; //store word
         
         assign CPU_is_addi_a1   = CPU_dec_bits_a1 ==? 11'bx_000_0010011; //add immediate
         assign CPU_is_slti_a1   = CPU_dec_bits_a1 ==? 11'bx_010_0010011; //set less than immediate
         assign CPU_is_sltiu_a1  = CPU_dec_bits_a1 ==? 11'bx_011_0010011; //set less than immediate (unsigned)
         assign CPU_is_xori_a1   = CPU_dec_bits_a1 ==? 11'bx_100_0010011; //xor immediate
         assign CPU_is_ori_a1    = CPU_dec_bits_a1 ==? 11'bx_110_0010011; //or immediate
         assign CPU_is_andi_a1   = CPU_dec_bits_a1 ==? 11'bx_111_0010011; //and immediate
         assign CPU_is_slli_a1   = CPU_dec_bits_a1 ==? 11'b0_001_0010011; //shift left logical immediate
         assign CPU_is_srli_a1   = CPU_dec_bits_a1 ==? 11'b0_101_0010011; //shift right logical immediate
         assign CPU_is_srai_a1   = CPU_dec_bits_a1 ==? 11'b1_101_0010011; //shift right arithmetic immediate
         
         assign CPU_is_add_a1    = CPU_dec_bits_a1 ==? 11'b0_000_0110011; //addition
         assign CPU_is_sub_a1    = CPU_dec_bits_a1 ==? 11'b1_000_0010011; //subtraction
         assign CPU_is_sll_a1    = CPU_dec_bits_a1 ==? 11'b0_001_0010011; //shift left logical
         assign CPU_is_slt_a1    = CPU_dec_bits_a1 ==? 11'b0_010_0010011; //set less than
         assign CPU_is_sltu_a1   = CPU_dec_bits_a1 ==? 11'b0_011_0010011; //set less than (unsigned)
         assign CPU_is_xor_a1    = CPU_dec_bits_a1 ==? 11'b0_100_0010011; //xor
         assign CPU_is_srl_a1    = CPU_dec_bits_a1 ==? 11'b0_101_0010011; //shift right logical
         assign CPU_is_sra_a1    = CPU_dec_bits_a1 ==? 11'b1_101_0010011; //shift right arithmetic
         assign CPU_is_or_a1     = CPU_dec_bits_a1 ==? 11'b0_110_0010011; //or
         assign CPU_is_and_a1    = CPU_dec_bits_a1 ==? 11'b0_111_0010011; //and

      //_@2
         // REGISTER FILE READ
         assign CPU_rf_rd_en1_a2 = CPU_rs1_valid_a2;
         assign CPU_rf_rd_index1_a2[4:0] = CPU_rs1_a2;

         assign CPU_rf_rd_en2_a2 = CPU_rs2_valid_a2;
         assign CPU_rf_rd_index2_a2[4:0] = CPU_rs2_a2;
         
         // COMPUTE TARGET BRANCH
         assign CPU_br_tgt_pc_a2[31:0] = CPU_pc_a2 + CPU_imm_a2;
         assign CPU_jalr_tgt_pc_a2[31:0] = CPU_src1_value_a2 + CPU_imm_a2; //compute jump target
         
         // ALU SOURCES (with RAW hazard handling)
         assign CPU_src1_value_a2[31:0] = (CPU_rf_wr_index_a3 == CPU_rf_rd_index1_a2) && CPU_rf_wr_en_a3 ?
                              CPU_rf_wr_data_a3 :
                                 CPU_rf_rd_data1_a2; //check if the previous reg write is reg read src 1.
         assign CPU_src2_value_a2[31:0] = (CPU_rf_wr_index_a3 == CPU_rf_rd_index2_a2) && CPU_rf_wr_en_a3 ?
                              CPU_rf_wr_data_a3 :
                                 CPU_rf_rd_data2_a2; //check if the previous reg write is reg read src 2.
      //_@3
         // ALU EXECUTE
         assign CPU_result_a3[31:0] = CPU_is_lui_a3     ? {CPU_imm_a3[31:12], 12'b0} :
                         CPU_is_auipc_a3   ? CPU_pc_a3 + CPU_imm_a3 :
                         CPU_is_jal_a3     ? CPU_pc_a3 + 32'd4 :
                         CPU_is_jalr_a3    ? CPU_pc_a3 + 32'd4 :
                         CPU_is_load_a3    ? CPU_src1_value_a3 + CPU_imm_a3:
                         CPU_is_s_instr_a3 ? CPU_src1_value_a3 + CPU_imm_a3:
                         CPU_is_addi_a3    ? CPU_src1_value_a3 + CPU_imm_a3:
                         CPU_is_slti_a3    ? ((CPU_src1_value_a3[31] == CPU_imm_a3[31]) ? CPU_sltiu_result_a3 : {31'b0, CPU_src1_value_a3[31]}) :
                         CPU_is_sltiu_a3   ? CPU_sltiu_result_a3:
                         CPU_is_xori_a3    ? CPU_src1_value_a3 ^ CPU_imm_a3 :
                         CPU_is_ori_a3     ? CPU_src1_value_a3 | CPU_imm_a3 :
                         CPU_is_andi_a3    ? CPU_src1_value_a3 & CPU_imm_a3 :
                         CPU_is_slli_a3    ? CPU_src1_value_a3 << CPU_imm_a3[5:0] :
                         CPU_is_srli_a3    ? CPU_src1_value_a3 >> CPU_imm_a3[5:0] :
                         CPU_is_srai_a3    ? {{32{CPU_src1_value_a3[31]}}, CPU_src1_value_a3} >> CPU_imm_a3[4:0] :
                         CPU_is_add_a3     ? CPU_src1_value_a3 + CPU_src2_value_a3:
                         CPU_is_sub_a3     ? CPU_src1_value_a3 - CPU_src2_value_a3 :
                         CPU_is_sll_a3     ? CPU_src1_value_a3 << CPU_src2_value_a3[4:0] :
                         CPU_is_slt_a3     ? ((CPU_src1_value_a3[31] == CPU_src2_value_a3[31]) ? CPU_sltu_result_a3 : {31'b0, CPU_src1_value_a3[31]}) :
                         CPU_is_sltu_a3    ? CPU_sltu_result_a3 :
                         CPU_is_xor_a3     ? CPU_src1_value_a3 ^ CPU_src2_value_a3 :
                         CPU_is_srl_a3     ? CPU_src1_value_a3 >> CPU_src2_value_a3[4:0] :
                         CPU_is_sra_a3     ? {{32{CPU_src1_value_a3[31]}}, CPU_src1_value_a3} >> CPU_src2_value_a3[4:0] :
                         CPU_is_or_a3      ? CPU_src1_value_a3 | CPU_src2_value_a3 :
                         CPU_is_and_a3     ? CPU_src1_value_a3 & CPU_src2_value_a3 :
                         32'bx;
         
         assign CPU_sltu_result_a3[31:0]  = CPU_src1_value_a3 < CPU_src2_value_a3;
         assign CPU_sltiu_result_a3[31:0] = CPU_src1_value_a3 < CPU_imm_a3;
         
         assign CPU_taken_br_a3 = CPU_is_beq_a3  ? (CPU_src1_value_a3 == CPU_src2_value_a3) :
                     CPU_is_bne_a3  ? (CPU_src1_value_a3 != CPU_src2_value_a3) :
                     CPU_is_blt_a3  ? ((CPU_src1_value_a3 < CPU_src2_value_a3)  ^ (CPU_src1_value_a3[31] != CPU_src2_value_a3[31])) :
                     CPU_is_bge_a3  ? ((CPU_src1_value_a3 >= CPU_src2_value_a3) ^ (CPU_src1_value_a3[31] != CPU_src2_value_a3[31])) :
                     CPU_is_bltu_a3 ? (CPU_src1_value_a3 < CPU_src2_value_a3)  : //bitwise ops in verilog default to unsigned.
                     CPU_is_bgeu_a3 ? (CPU_src1_value_a3 >= CPU_src2_value_a3) :
                     1'b0;
         
         // PIPELINE VALIDITY
         assign CPU_valid_a3 = !(CPU_valid_taken_br_a4 || CPU_valid_taken_br_a5 || CPU_is_load_a4 || CPU_is_load_a5 || CPU_valid_jump_a4 || CPU_valid_jump_a5);
         assign CPU_valid_taken_br_a3 = CPU_valid_a3 && CPU_taken_br_a3; //branch CF hazard handling
         assign CPU_valid_load_a3 = CPU_valid_a3 && CPU_is_load_a3; //RAW DMem hazard handling
         assign CPU_valid_jump_a3 = CPU_valid_a3 && CPU_is_jump_a3;
         
         // REGISTER FILE WRITE
         assign CPU_rf_wr_en_a3 = (CPU_valid_a3 && CPU_rd_valid_a3 && (CPU_rd_a3 != 5'b0)) || CPU_valid_load_a5; //ensure that writes have a destination and NOT x0.
         assign CPU_rf_wr_index_a3[4:0] = CPU_valid_load_a5 ? CPU_rd_a5 : CPU_rd_a3; //use the load destination on valid load
         assign CPU_rf_wr_data_a3[31:0] = CPU_valid_load_a5 ? CPU_ld_data_a5 : CPU_result_a3; //write loaded data on valid load
         
      //_@4
         // DATA MEMORY
         assign CPU_dmem_rd_en_a4 = CPU_is_load_a4;              //enable for loads
         assign CPU_dmem_wr_en_a4 = CPU_valid_a4 && CPU_is_s_instr_a4; //enable for stores
         assign CPU_dmem_addr_a4[3:0]  = CPU_result_a4[5:2];     //word addressed and calculated from the instruction
         assign CPU_dmem_wr_data_a4[31:0] = CPU_src2_value_a4;
      
      //_@5
         assign CPU_ld_data_a5[31:0] = CPU_dmem_rd_data_a5; //wait a cycle for the data
         
   assign passed = CPU_Xreg_value_a6[15] == (1+2+3+4+5+6+7+8+9);
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 100;
   assign failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   //_|cpu
      `line 20 "riscvshelllib.tlv" 1   // Instantiated from core.tlv, 249 as: m4+imem(@1)
         // Instruction Memory containing program defined by m4_asm(...) instantiations.
         //_@1
            
            
               
               
               
                  
               
            
               
            
               
            
            
            //_?$imem_rd_en
               assign CPU_imem_rd_data_a1[31:0] = (CPU_imem_rd_addr_a1 == 0) ? idata0 :
                              (CPU_imem_rd_addr_a1 == 1) ? idata1 :
                              (CPU_imem_rd_addr_a1 == 2) ? idata2 :
                              (CPU_imem_rd_addr_a1 == 3) ? idata3 :
                              (CPU_imem_rd_addr_a1 == 4) ? idata4 :
                              (CPU_imem_rd_addr_a1 == 5) ? idata5 :
                              (CPU_imem_rd_addr_a1 == 6) ? idata6 :
                              (CPU_imem_rd_addr_a1 == 7) ? idata7 :
                              (CPU_imem_rd_addr_a1 == 8) ? idata8 :
                              (CPU_imem_rd_addr_a1 == 9) ? idata9 :
                              (CPU_imem_rd_addr_a1 == 10) ? idata10 :
                              (CPU_imem_rd_addr_a1 == 11) ? idata11 :
                              (CPU_imem_rd_addr_a1 == 12) ? idata12 :
                              (CPU_imem_rd_addr_a1 == 13) ? idata13 :
                              (CPU_imem_rd_addr_a1 == 14) ? idata14 :
                              (CPU_imem_rd_addr_a1 == 15) ? idata15 :
                              (CPU_imem_rd_addr_a1 == 16) ? idata16 :
                              (CPU_imem_rd_addr_a1 == 17) ? idata17 :
                              (CPU_imem_rd_addr_a1 == 18) ? idata18 :
                              (CPU_imem_rd_addr_a1 == 19) ? idata19 :
                              (CPU_imem_rd_addr_a1 == 20) ? idata20 :
                              (CPU_imem_rd_addr_a1 == 21) ? idata21 :
                              (CPU_imem_rd_addr_a1 == 22) ? idata22 :
                              (CPU_imem_rd_addr_a1 == 23) ? idata23 :
                              (CPU_imem_rd_addr_a1 == 24) ? idata24 :
                              (CPU_imem_rd_addr_a1 == 25) ? idata25 :
                              (CPU_imem_rd_addr_a1 == 26) ? idata26 :
                              (CPU_imem_rd_addr_a1 == 27) ? idata27 :
                              (CPU_imem_rd_addr_a1 == 28) ? idata28 :
                              (CPU_imem_rd_addr_a1 == 29) ? idata29 :
                              (CPU_imem_rd_addr_a1 == 30) ? idata30 :
                              (CPU_imem_rd_addr_a1 == 31) ? idata31 :
                              31'b0 ;
              
          
      //_\end_source    // Args: (read stage)
      `line 250 "core.tlv" 2
      `line 75 "riscvshelllib.tlv" 1   // Instantiated from core.tlv, 250 as: m4+rf(@2, @3)
         // Reg File
         //_@3
            for (xreg = 0; xreg <= 31; xreg++) begin : L1_CPU_Xreg logic L1_wr_a3; //_/xreg
               assign L1_wr_a3 = CPU_rf_wr_en_a3 && (CPU_rf_wr_index_a3 != 5'b0) && (CPU_rf_wr_index_a3 == xreg);
               assign CPU_Xreg_value_a3[xreg][31:0] = CPU_reset_a3 ?   xreg           :
                              L1_wr_a3        ?   CPU_rf_wr_data_a3 :
                                             CPU_Xreg_value_a4[xreg][31:0]; end
         //_@2
            //_?$rf_rd_en1
               assign CPU_rf_rd_data1_a2[31:0] = CPU_Xreg_value_a4[CPU_rf_rd_index1_a2];
            //_?$rf_rd_en2
               assign CPU_rf_rd_data2_a2[31:0] = CPU_Xreg_value_a4[CPU_rf_rd_index2_a2];
            `BOGUS_USE(CPU_rf_rd_data1_a2 CPU_rf_rd_data2_a2) 
      //_\end_source  // Args: (read stage, write stage) - if equal, no register bypass is required
      `line 251 "core.tlv" 2
      `line 92 "riscvshelllib.tlv" 1   // Instantiated from core.tlv, 251 as: m4+dmem(@4)
         // Data Memory
         //_@4
            for (dmem = 0; dmem <= 15; dmem++) begin : L1_CPU_Dmem logic L1_wr_a4; //_/dmem
               assign L1_wr_a4 = CPU_dmem_wr_en_a4 && (CPU_dmem_addr_a4 == dmem);
               assign CPU_Dmem_value_a4[dmem][31:0] = CPU_reset_a4 ?   dmem :
                              L1_wr_a4        ?   CPU_dmem_wr_data_a4 :
                                             CPU_Dmem_value_a5[dmem][31:0]; end
                                        
            //_?$dmem_rd_en
               assign CPU_dmem_rd_data_a4[31:0] = CPU_Dmem_value_a5[CPU_dmem_addr_a4];
            `BOGUS_USE(CPU_dmem_rd_data_a4)
      //_\end_source    // Args: (read/write stage)
      `line 252 "core.tlv" 2

   `line 145 "riscvshelllib.tlv" 1   // Instantiated from core.tlv, 253 as: m4+cpu_viz(@4)
      
      
      
         
         
         
            
            
            
               
            
               
      
      
         
         
      
         
            
               
               
               
                  
                  
                     
                     
                        
                        
                        
                        
                     
                  
                  
                
         
            
               
               
               
               
   
               
               
               
               
               
               
   
               
               
               
   
               
   
               
               
               
               
               
               
               
               
               
               
   
               
               
               
               
               
                  
                  
                  
                  
               
                  
                  
                  
                  
               
               
               
               
               
               
               
               
               
               
         
            
            
            
               
               
            
            
               
               
   
            
            
            
            
               
               
                  
                  
                  
                  
                  
                                                     
                  
                     
                     
                     
                     
                     
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                     
                  
                  
                     
                                
                                
                  
                  
                            
                            
                  
                     
                     
                     
                     
                     
                  
                  
               
            
            
            
            
               
                  
                  
                     
                     
                        
                           
                           
                           
                        
                        
                     
                  
                  
                     
                        
                        
                        
                     
                     
                  
                  
                     
                     
                     
                     
                     
                        
                        
                  
                  
                  
            
            
            
            
               
                  
                  
                     
                     
                     
                           
                           
                           
                           
                        
                        
                     
                  
                  
                     
                        
                        
                        
                        
                     
                     
                  
                  
                     
                     
                     
                     
                     
                        
                        
                  
                  
                  
      
      
   //_\end_source    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
   `line 254 "core.tlv" 2
//_\SV
   endmodule


// Undefine macros defined by SandPiper (in "riscv_gen.sv").
`undef BOGUS_USE
